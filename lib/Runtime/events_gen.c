
/*** !!! this code has been autogenerated by utils/gen_sal.py, do not modify it directly. !!! ***/


#include <unistd.h>
#include <sys/types.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <sys/stat.h>

#include <castor/debug.h>
#include <castor/rrlog.h>
#include <castor/rrplay.h>
#include <castor/rrgq.h>
#include <castor/mtx.h>
#include <castor/events.h>

#include "util.h"




#include <sys/param.h>
#include <sys/sysent.h>
#include <sys/sysproto.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/user.h>

#if !defined(PAD64_REQUIRED) && (defined(__powerpc__) || defined(__mips__))
#define PAD64_REQUIRED
#endif















ssize_t
__rr_read(int fd, void *buf, size_t nbyte)
{
    ssize_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_read, fd, buf, nbyte);
    case RRMODE_RECORD:
	result = syscall(SYS_read, fd, buf, nbyte);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_READ;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, nbyte);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_READ);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, nbyte);
	}
	break;
    }
    return result;
}

int
__rr_link(const char *path, const char *to)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_link, path, to);
    case RRMODE_RECORD:
	result = syscall(SYS_link, path, to);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_LINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_LINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_unlink(const char *path)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_unlink, path);
    case RRMODE_RECORD:
	result = syscall(SYS_unlink, path);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_UNLINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_UNLINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chdir(const char *path)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_chdir, path);
    case RRMODE_RECORD:
	result = syscall(SYS_chdir, path);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CHDIR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CHDIR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchdir(int fd)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fchdir, fd);
    case RRMODE_RECORD:
	result = syscall(SYS_fchdir, fd);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FCHDIR;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FCHDIR);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chmod(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_chmod, path, mode);
    case RRMODE_RECORD:
	result = syscall(SYS_chmod, path, mode);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CHMOD;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CHMOD);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setuid(uid_t uid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_setuid, uid);
    case RRMODE_RECORD:
	result = syscall(SYS_setuid, uid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_sendmsg(int s, const struct msghdr *msg, int flags)
{
    ssize_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_sendmsg, s, msg, flags);
    case RRMODE_RECORD:
	result = syscall(SYS_sendmsg, s, msg, flags);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SENDMSG;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SENDMSG);
	AssertObject(e, (uint64_t) s);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_accept(int s, struct sockaddr *__restrict name, __socklen_t * anamelen)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_accept, s, name, anamelen);
    case RRMODE_RECORD:
	result = syscall(SYS_accept, s, name, anamelen);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_ACCEPT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, *anamelen);
	    }
	    if (anamelen != NULL) {
		logData((uint8_t *) anamelen, sizeof(__socklen_t));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_ACCEPT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, *anamelen);
	    }
	    if (anamelen != NULL) {
		logData((uint8_t *) anamelen, sizeof(__socklen_t));
	    }
	}
	break;
    }
    return result;
}

int
__rr_getpeername(int fdes, struct sockaddr *__restrict asa, __socklen_t * alen)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_getpeername, fdes, asa, alen);
    case RRMODE_RECORD:
	result = syscall(SYS_getpeername, fdes, asa, alen);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_GETPEERNAME;
	e->objectId = (uint64_t) fdes;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) asa, *alen);
	    if (alen != NULL) {
		logData((uint8_t *) alen, sizeof(__socklen_t));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_GETPEERNAME);
	AssertObject(e, (uint64_t) fdes);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) asa, *alen);
	    if (alen != NULL) {
		logData((uint8_t *) alen, sizeof(__socklen_t));
	    }
	}
	break;
    }
    return result;
}

int
__rr_getsockname(int fdes, struct sockaddr *__restrict asa, __socklen_t * alen)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_getsockname, fdes, asa, alen);
    case RRMODE_RECORD:
	result = syscall(SYS_getsockname, fdes, asa, alen);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_GETSOCKNAME;
	e->objectId = (uint64_t) fdes;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) asa, *alen);
	    logData((uint8_t *) alen, sizeof(__socklen_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_GETSOCKNAME);
	AssertObject(e, (uint64_t) fdes);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) asa, *alen);
	    logData((uint8_t *) alen, sizeof(__socklen_t));
	}
	break;
    }
    return result;
}

int
__rr_access(const char *path, int amode)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_access, path, amode);
    case RRMODE_RECORD:
	result = syscall(SYS_access, path, amode);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_ACCESS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_ACCESS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_stat(const char *path, struct stat *ub)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_stat, path, ub);
    case RRMODE_RECORD:
	result = syscall(SYS_stat, path, ub);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_STAT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) ub, sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_STAT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) ub, sizeof(struct stat));
	}
	break;
    }
    return result;
}

int
__rr_lstat(const char *path, struct stat *ub)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_lstat, path, ub);
    case RRMODE_RECORD:
	result = syscall(SYS_lstat, path, ub);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_LSTAT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) ub, sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_LSTAT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) ub, sizeof(struct stat));
	}
	break;
    }
    return result;
}

int
__rr_symlink(const char *path, const char *link)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_symlink, path, link);
    case RRMODE_RECORD:
	result = syscall(SYS_symlink, path, link);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SYMLINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SYMLINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_readlink(const char *path, char *buf, size_t count)
{
    ssize_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_readlink, path, buf, count);
    case RRMODE_RECORD:
	result = syscall(SYS_readlink, path, buf, count);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_READLINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, count * sizeof(char));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_READLINK);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, count * sizeof(char));
	}
	break;
    }
    return result;
}

int
__rr_setgroups(int gidsetsize, const gid_t * gidset)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_setgroups, gidsetsize, gidset);
    case RRMODE_RECORD:
	result = syscall(SYS_setgroups, gidsetsize, gidset);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETGROUPS;
	e->objectId = (uint64_t) gidsetsize;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETGROUPS);
	AssertObject(e, (uint64_t) gidsetsize);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fsync(int fd)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fsync, fd);
    case RRMODE_RECORD:
	result = syscall(SYS_fsync, fd);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FSYNC;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FSYNC);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_socket(int domain, int type, int protocol)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_socket, domain, type, protocol);
    case RRMODE_RECORD:
	result = syscall(SYS_socket, domain, type, protocol);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SOCKET;
	e->objectId = (uint64_t) domain;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SOCKET);
	AssertObject(e, (uint64_t) domain);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_connect(int s, const struct sockaddr *name, __socklen_t namelen)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_connect, s, name, namelen);
    case RRMODE_RECORD:
	result = syscall(SYS_connect, s, name, namelen);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CONNECT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CONNECT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_bind(int s, const struct sockaddr *name, __socklen_t namelen)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_bind, s, name, namelen);
    case RRMODE_RECORD:
	result = syscall(SYS_bind, s, name, namelen);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_BIND;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_BIND);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setsockopt(int s, int level, int name, const void *val, __socklen_t valsize)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_setsockopt, s, level, name, val, valsize);
    case RRMODE_RECORD:
	result = syscall(SYS_setsockopt, s, level, name, val, valsize);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETSOCKOPT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETSOCKOPT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_listen(int s, int backlog)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_listen, s, backlog);
    case RRMODE_RECORD:
	result = syscall(SYS_listen, s, backlog);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_LISTEN;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_LISTEN);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getrusage(int who, struct rusage *rusage)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_getrusage, who, rusage);
    case RRMODE_RECORD:
	result = syscall(SYS_getrusage, who, rusage);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_GETRUSAGE;
	e->objectId = (uint64_t) who;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) rusage, sizeof(struct rusage));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_GETRUSAGE);
	AssertObject(e, (uint64_t) who);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) rusage, sizeof(struct rusage));
	}
	break;
    }
    return result;
}

int
__rr_fchmod(int fd, mode_t mode)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fchmod, fd, mode);
    case RRMODE_RECORD:
	result = syscall(SYS_fchmod, fd, mode);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FCHMOD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FCHMOD);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_rename(const char *from, const char *to)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_rename, from, to);
    case RRMODE_RECORD:
	result = syscall(SYS_rename, from, to);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_RENAME;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_RENAME);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_flock(int fd, int how)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_flock, fd, how);
    case RRMODE_RECORD:
	result = syscall(SYS_flock, fd, how);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FLOCK;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FLOCK);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, __socklen_t tolen)
{
    ssize_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_sendto, s, buf, len, flags, to, tolen);
    case RRMODE_RECORD:
	result = syscall(SYS_sendto, s, buf, len, flags, to, tolen);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SENDTO;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SENDTO);
	AssertObject(e, (uint64_t) s);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_shutdown(int s, int how)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_shutdown, s, how);
    case RRMODE_RECORD:
	result = syscall(SYS_shutdown, s, how);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SHUTDOWN;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SHUTDOWN);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_mkdir(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_mkdir, path, mode);
    case RRMODE_RECORD:
	result = syscall(SYS_mkdir, path, mode);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_MKDIR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_MKDIR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_rmdir(const char *path)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_rmdir, path);
    case RRMODE_RECORD:
	result = syscall(SYS_rmdir, path);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_RMDIR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_RMDIR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setgid(gid_t gid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_setgid, gid);
    case RRMODE_RECORD:
	result = syscall(SYS_setgid, gid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setegid(gid_t egid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_setegid, egid);
    case RRMODE_RECORD:
	result = syscall(SYS_setegid, egid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETEGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETEGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_seteuid(uid_t euid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_seteuid, euid);
    case RRMODE_RECORD:
	result = syscall(SYS_seteuid, euid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETEUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETEUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getrlimit(int which, struct rlimit *rlp)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_getrlimit, which, rlp);
    case RRMODE_RECORD:
	result = syscall(SYS_getrlimit, which, rlp);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_GETRLIMIT;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) rlp, sizeof(struct rlimit));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_GETRLIMIT);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) rlp, sizeof(struct rlimit));
	}
	break;
    }
    return result;
}

int
__rr_setrlimit(int which, const struct rlimit *rlp)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_setrlimit, which, rlp);
    case RRMODE_RECORD:
	result = syscall(SYS_setrlimit, which, rlp);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_SETRLIMIT;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_SETRLIMIT);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_lchmod(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_lchmod, path, mode);
    case RRMODE_RECORD:
	result = syscall(SYS_lchmod, path, mode);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_LCHMOD;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_LCHMOD);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_kqueue()
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_kqueue);
    case RRMODE_RECORD:
	result = syscall(SYS_kqueue);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_KQUEUE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_KQUEUE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_eaccess(const char *path, int amode)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_eaccess, path, amode);
    case RRMODE_RECORD:
	result = syscall(SYS_eaccess, path, amode);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_EACCESS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_EACCESS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_pread(int fd, void *buf, size_t nbyte, off_t offset)
{
    ssize_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_pread, fd, buf, nbyte, offset);
    case RRMODE_RECORD:
	result = syscall(SYS_pread, fd, buf, nbyte, offset);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_PREAD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, nbyte);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_PREAD);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, nbyte);
	}
	break;
    }
    return result;
}

off_t
__rr_lseek(int fd, off_t offset, int whence)
{
    off_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_lseek, fd, offset, whence);
    case RRMODE_RECORD:
	result = syscall(SYS_lseek, fd, offset, whence);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_LSEEK;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_LSEEK);
	AssertObject(e, (uint64_t) fd);
	result = (off_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_truncate(const char *path, off_t length)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_truncate, path, length);
    case RRMODE_RECORD:
	result = syscall(SYS_truncate, path, length);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_TRUNCATE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_TRUNCATE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_ftruncate(int fd, off_t length)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_ftruncate, fd, length);
    case RRMODE_RECORD:
	result = syscall(SYS_ftruncate, fd, length);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FTRUNCATE;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FTRUNCATE);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cpuset(cpusetid_t * setid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cpuset, setid);
    case RRMODE_RECORD:
	result = syscall(SYS_cpuset, setid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CPUSET;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) setid, sizeof(cpusetid_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CPUSET);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) setid, sizeof(cpusetid_t));
	}
	break;
    }
    return result;
}

int
__rr_cpuset_setid(cpuwhich_t which, id_t id, cpusetid_t setid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cpuset_setid, which, id, setid);
    case RRMODE_RECORD:
	result = syscall(SYS_cpuset_setid, which, id, setid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CPUSET_SETID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CPUSET_SETID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cpuset_getid(cpulevel_t level, cpuwhich_t which, id_t id, cpusetid_t * setid)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cpuset_getid, level, which, id, setid);
    case RRMODE_RECORD:
	result = syscall(SYS_cpuset_getid, level, which, id, setid);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CPUSET_GETID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) setid, sizeof(cpusetid_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CPUSET_GETID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) setid, sizeof(cpusetid_t));
	}
	break;
    }
    return result;
}

int
__rr_cpuset_getaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, cpuset_t * mask)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cpuset_getaffinity, level, which, id, cpusetsize, mask);
    case RRMODE_RECORD:
	result = syscall(SYS_cpuset_getaffinity, level, which, id, cpusetsize, mask);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CPUSET_GETAFFINITY;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) mask, sizeof(cpuset_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CPUSET_GETAFFINITY);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) mask, sizeof(cpuset_t));
	}
	break;
    }
    return result;
}

int
__rr_cpuset_setaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, const cpuset_t * mask)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cpuset_setaffinity, level, which, id, cpusetsize, mask);
    case RRMODE_RECORD:
	result = syscall(SYS_cpuset_setaffinity, level, which, id, cpusetsize, mask);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CPUSET_SETAFFINITY;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) mask, sizeof(const cpuset_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CPUSET_SETAFFINITY);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) mask, sizeof(const cpuset_t));
	}
	break;
    }
    return result;
}

int
__rr_faccessat(int fd, const char *path, int amode, int flag)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_faccessat, fd, path, amode, flag);
    case RRMODE_RECORD:
	result = syscall(SYS_faccessat, fd, path, amode, flag);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FACCESSAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FACCESSAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchmodat(int fd, const char *path, mode_t mode, int flag)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fchmodat, fd, path, mode, flag);
    case RRMODE_RECORD:
	result = syscall(SYS_fchmodat, fd, path, mode, flag);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FCHMODAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FCHMODAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_linkat, fd1, path1, fd2, path2, flag);
    case RRMODE_RECORD:
	result = syscall(SYS_linkat, fd1, path1, fd2, path2, flag);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_LINKAT;
	e->objectId = (uint64_t) fd1;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_LINKAT);
	AssertObject(e, (uint64_t) fd1);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_readlinkat(int fd, const char *path, char *buf, size_t bufsize)
{
    ssize_t	    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_readlinkat, fd, path, buf, bufsize);
    case RRMODE_RECORD:
	result = syscall(SYS_readlinkat, fd, path, buf, bufsize);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_READLINKAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, bufsize);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_READLINKAT);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, bufsize);
	}
	break;
    }
    return result;
}

int
__rr_unlinkat(int fd, const char *path, int flag)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_unlinkat, fd, path, flag);
    case RRMODE_RECORD:
	result = syscall(SYS_unlinkat, fd, path, flag);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_UNLINKAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_UNLINKAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_enter()
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cap_enter);
    case RRMODE_RECORD:
	result = syscall(SYS_cap_enter);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CAP_ENTER;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CAP_ENTER);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_rights_limit(int fd, cap_rights_t * rightsp)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_cap_rights_limit, fd, rightsp);
    case RRMODE_RECORD:
	result = syscall(SYS_cap_rights_limit, fd, rightsp);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_CAP_RIGHTS_LIMIT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_CAP_RIGHTS_LIMIT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_accept4(int s, struct sockaddr *__restrict name, __socklen_t * __restrict anamelen, int flags)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_accept4, s, name, anamelen, flags);
    case RRMODE_RECORD:
	result = syscall(SYS_accept4, s, name, anamelen, flags);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_ACCEPT4;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, *anamelen);
	    }
	    if (anamelen != NULL) {
		logData((uint8_t *) anamelen, sizeof(__socklen_t));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_ACCEPT4);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, *anamelen);
	    }
	    if (anamelen != NULL) {
		logData((uint8_t *) anamelen, sizeof(__socklen_t));
	    }
	}
	break;
    }
    return result;
}

int
__rr_fstat(int fd, struct stat *sb)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fstat, fd, sb);
    case RRMODE_RECORD:
	result = syscall(SYS_fstat, fd, sb);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FSTAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) sb, sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FSTAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) sb, sizeof(struct stat));
	}
	break;
    }
    return result;
}

int
__rr_fstatat(int fd, const char *path, struct stat *buf, int flag)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fstatat, fd, path, buf, flag);
    case RRMODE_RECORD:
	result = syscall(SYS_fstatat, fd, path, buf, flag);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FSTATAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) buf, sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FSTATAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) buf, sizeof(struct stat));
	}
	break;
    }
    return result;
}

int
__rr_statfs(const char *path, struct statfs *buf)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_statfs, path, buf);
    case RRMODE_RECORD:
	result = syscall(SYS_statfs, path, buf);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_STATFS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) buf, sizeof(struct statfs));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_STATFS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) buf, sizeof(struct statfs));
	}
	break;
    }
    return result;
}

int
__rr_fstatfs(int fd, struct statfs *buf)
{
    int		    result;
    RRLogEntry     *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return syscall(SYS_fstatfs, fd, buf);
    case RRMODE_RECORD:
	result = syscall(SYS_fstatfs, fd, buf);
	e = RRLog_Alloc(rrlog, threadId);
	e->event = RREVENT_FSTATFS;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) buf, sizeof(struct statfs));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, threadId);
	AssertEvent(e, RREVENT_FSTATFS);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result == 0) {
	    logData((uint8_t *) buf, sizeof(struct statfs));
	}
	break;
    }
    return result;
}

BIND_REF(read);
BIND_REF(link);
BIND_REF(unlink);
BIND_REF(chdir);
BIND_REF(fchdir);
BIND_REF(chmod);
BIND_REF(setuid);
BIND_REF(sendmsg);
BIND_REF(accept);
BIND_REF(getpeername);
BIND_REF(getsockname);
BIND_REF(access);
BIND_REF(stat);
BIND_REF(lstat);
BIND_REF(symlink);
BIND_REF(readlink);
BIND_REF(setgroups);
BIND_REF(fsync);
BIND_REF(socket);
BIND_REF(connect);
BIND_REF(bind);
BIND_REF(setsockopt);
BIND_REF(listen);
BIND_REF(getrusage);
BIND_REF(fchmod);
BIND_REF(rename);
BIND_REF(flock);
BIND_REF(sendto);
BIND_REF(shutdown);
BIND_REF(mkdir);
BIND_REF(rmdir);
BIND_REF(setgid);
BIND_REF(setegid);
BIND_REF(seteuid);
BIND_REF(getrlimit);
BIND_REF(setrlimit);
BIND_REF(lchmod);
BIND_REF(kqueue);
BIND_REF(eaccess);
BIND_REF(pread);
BIND_REF(lseek);
BIND_REF(truncate);
BIND_REF(ftruncate);
BIND_REF(cpuset);
BIND_REF(cpuset_setid);
BIND_REF(cpuset_getid);
BIND_REF(cpuset_getaffinity);
BIND_REF(cpuset_setaffinity);
BIND_REF(faccessat);
BIND_REF(fchmodat);
BIND_REF(linkat);
BIND_REF(readlinkat);
BIND_REF(unlinkat);
BIND_REF(cap_enter);
BIND_REF(cap_rights_limit);
BIND_REF(accept4);
BIND_REF(fstat);
BIND_REF(fstatat);
BIND_REF(statfs);
BIND_REF(fstatfs);
