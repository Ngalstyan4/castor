





#include <sys/param.h>
#include <sys/sysent.h>
#include <sys/sysproto.h>











/*** !!! this code has been autogenerated by utils/gen_sal.py, do not modify it directly. !!! ***/


#include <stdio.h>
#include <errno.h>
#include <time.h>
#include <signal.h>


#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <kenv.h>
#include <poll.h>

#include <semaphore.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ptrace.h>
#include <sys/event.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/resource.h>
#include <sys/param.h>
#include <sys/cpuset.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/stat.h>
#include <sys/capsicum.h>
#include <sys/extattr.h>
#include <sys/time.h>
#include <sys/uuid.h>
#include <sys/reboot.h>
#include <ufs/ufs/quota.h>
#include <sys/timex.h>
#include <sys/timeffc.h>
#include <sys/rctl.h>
#include <bsm/audit.h>
#include <sys/ucred.h>

#ifndef GEN_SAL

#include <castor/debug.h>
#include <castor/rrlog.h>
#include <castor/rrplay.h>
#include <castor/rrgq.h>
#include <castor/mtx.h>
#include <castor/events.h>

#endif

ssize_t
__rr_read(int fd, void *buf, size_t nbyte){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_read, fd, buf, nbyte);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_read, fd, buf, nbyte);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_READ;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)result);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_READ);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)result);
	}
	break;
    }
    return result;
}

int
__rr_link(const char *path, const char *link)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_link, path, link);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_link, path, link);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_unlink(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_unlink, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_unlink, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UNLINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UNLINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chdir(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_chdir, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_chdir, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CHDIR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CHDIR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchdir(int fd)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fchdir, fd);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fchdir, fd);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FCHDIR;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FCHDIR);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chmod(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_chmod, path, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_chmod, path, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CHMOD;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CHMOD);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chown(const char *path, uid_t uid, gid_t gid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_chown, path, uid, gid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_chown, path, uid, gid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CHOWN;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CHOWN);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

pid_t
__rr_getpid() {
    pid_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getpid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getpid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETPID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETPID);
	result = (pid_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_mount(const char *type, const char *path, int flags, void *data)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_mount, type, path, flags, data);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_mount, type, path, flags, data);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_MOUNT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_MOUNT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_unmount(const char *path, int flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_unmount, path, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_unmount, path, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UNMOUNT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UNMOUNT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setuid(uid_t uid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setuid, uid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setuid, uid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

uid_t
__rr_getuid() {
    uid_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return (uid_t) __rr_syscall(SYS_getuid);
    case RRMODE_RECORD:
	result = (uid_t) __rr_syscall(SYS_getuid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETUID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETUID);
	result = (uid_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

uid_t
__rr_geteuid() {
    uid_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return (uid_t) __rr_syscall(SYS_geteuid);
    case RRMODE_RECORD:
	result = (uid_t) __rr_syscall(SYS_geteuid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETEUID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETEUID);
	result = (uid_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_sendmsg(int s, const struct msghdr *msg, int flags){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_sendmsg, s, msg, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_sendmsg, s, msg, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SENDMSG;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SENDMSG);
	AssertObject(e, (uint64_t) s);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_accept(int s, struct sockaddr *name, socklen_t * anamelen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_accept, s, name, anamelen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_accept, s, name, anamelen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_ACCEPT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    if (anamelen != NULL) {
		e->value[2] = (uint64_t) (*anamelen);
	    }
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, (unsigned long)*anamelen);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_ACCEPT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    if (anamelen != NULL) {
		(*anamelen) = (socklen_t) e->value[2];
	    }
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, (unsigned long)*anamelen);
	    }
	}
	break;
    }
    return result;
}

int
__rr_getpeername(int fdes, struct sockaddr *asa, socklen_t * alen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getpeername, fdes, asa, alen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getpeername, fdes, asa, alen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETPEERNAME;
	e->objectId = (uint64_t) fdes;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    if (alen != NULL) {
		e->value[2] = (uint64_t) (*alen);
	    }
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) asa, (unsigned long)*alen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETPEERNAME);
	AssertObject(e, (uint64_t) fdes);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    if (alen != NULL) {
		(*alen) = (socklen_t) e->value[2];
	    }
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) asa, (unsigned long)*alen);
	}
	break;
    }
    return result;
}

int
__rr_getsockname(int fdes, struct sockaddr *asa, socklen_t * alen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getsockname, fdes, asa, alen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getsockname, fdes, asa, alen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETSOCKNAME;
	e->objectId = (uint64_t) fdes;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*alen);
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) asa, (unsigned long)*alen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETSOCKNAME);
	AssertObject(e, (uint64_t) fdes);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*alen) = (socklen_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) asa, (unsigned long)*alen);
	}
	break;
    }
    return result;
}

int
__rr_access(const char *path, int amode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_access, path, amode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_access, path, amode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_ACCESS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_ACCESS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chflags(const char *path, unsigned long flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_chflags, path, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_chflags, path, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CHFLAGS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CHFLAGS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchflags(int fd, unsigned long flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fchflags, fd, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fchflags, fd, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FCHFLAGS;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FCHFLAGS);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

pid_t
__rr_getppid() {
    pid_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getppid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getppid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETPPID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETPPID);
	result = (pid_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_dup(int fd)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_dup, fd);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_dup, fd);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_DUP;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_DUP);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

gid_t
__rr_getegid() {
    gid_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return (gid_t) __rr_syscall(SYS_getegid);
    case RRMODE_RECORD:
	result = (gid_t) __rr_syscall(SYS_getegid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETEGID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETEGID);
	result = (gid_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

gid_t
__rr_getgid() {
    gid_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return (gid_t) __rr_syscall(SYS_getgid);
    case RRMODE_RECORD:
	result = (gid_t) __rr_syscall(SYS_getgid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETGID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETGID);
	result = (gid_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_acct(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_acct, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_acct, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_ACCT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_ACCT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_reboot(int opt)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_reboot, opt);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_reboot, opt);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_REBOOT;
	e->objectId = (uint64_t) opt;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_REBOOT);
	AssertObject(e, (uint64_t) opt);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_symlink(const char *path, const char *link)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_symlink, path, link);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_symlink, path, link);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SYMLINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SYMLINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_readlink(const char *path, char *buf, size_t count){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_readlink, path, buf, count);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_readlink, path, buf, count);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_READLINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)count);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_READLINK);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)count);
	}
	break;
    }
    return result;
}

mode_t
__rr_umask(mode_t newmask) {
    mode_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_umask, newmask);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_umask, newmask);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UMASK;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UMASK);
	result = (mode_t) e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chroot(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_chroot, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_chroot, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CHROOT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CHROOT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getgroups(int gidsetsize, gid_t * gidset)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getgroups, gidsetsize, gidset);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getgroups, gidsetsize, gidset);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETGROUPS;
	e->objectId = (uint64_t) gidsetsize;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (gidset != NULL) {
		logData((uint8_t *) gidset, (unsigned long)result * sizeof(gid_t));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETGROUPS);
	AssertObject(e, (uint64_t) gidsetsize);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (gidset != NULL) {
		logData((uint8_t *) gidset, (unsigned long)result * sizeof(gid_t));
	    }
	}
	break;
    }
    return result;
}

int
__rr_setgroups(int gidsetsize, const gid_t * gidset)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setgroups, gidsetsize, gidset);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setgroups, gidsetsize, gidset);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETGROUPS;
	e->objectId = (uint64_t) gidsetsize;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETGROUPS);
	AssertObject(e, (uint64_t) gidsetsize);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setitimer(int which, const struct itimerval *itv, struct itimerval *oitv)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setitimer, which, itv, oitv);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setitimer, which, itv, oitv);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETITIMER;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (oitv != NULL) {
		logData((uint8_t *) oitv, (unsigned long)sizeof(struct itimerval));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETITIMER);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (oitv != NULL) {
		logData((uint8_t *) oitv, (unsigned long)sizeof(struct itimerval));
	    }
	}
	break;
    }
    return result;
}

int
__rr_swapon(const char *name)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_swapon, name);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_swapon, name);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SWAPON;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SWAPON);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getitimer(int which, struct itimerval *itv)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getitimer, which, itv);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getitimer, which, itv);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETITIMER;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) itv, (unsigned long)sizeof(struct itimerval));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETITIMER);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) itv, (unsigned long)sizeof(struct itimerval));
	}
	break;
    }
    return result;
}

int
__rr_getdtablesize()
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getdtablesize);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getdtablesize);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETDTABLESIZE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETDTABLESIZE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_dup2(int from, int to)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_dup2, from, to);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_dup2, from, to);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_DUP2;
	e->objectId = (uint64_t) from;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_DUP2);
	AssertObject(e, (uint64_t) from);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_select(int nd, fd_set * in, fd_set * ou, fd_set * ex, struct timeval *tv)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_select, nd, in, ou, ex, tv);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_select, nd, in, ou, ex, tv);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SELECT;
	e->objectId = (uint64_t) nd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (in != NULL) {
		logData((uint8_t *) in, (unsigned long)sizeof(fd_set));
	    }
	    if (ou != NULL) {
		logData((uint8_t *) ou, (unsigned long)sizeof(fd_set));
	    }
	    if (ex != NULL) {
		logData((uint8_t *) ex, (unsigned long)sizeof(fd_set));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SELECT);
	AssertObject(e, (uint64_t) nd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (in != NULL) {
		logData((uint8_t *) in, (unsigned long)sizeof(fd_set));
	    }
	    if (ou != NULL) {
		logData((uint8_t *) ou, (unsigned long)sizeof(fd_set));
	    }
	    if (ex != NULL) {
		logData((uint8_t *) ex, (unsigned long)sizeof(fd_set));
	    }
	}
	break;
    }
    return result;
}

int
__rr_fsync(int fd)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fsync, fd);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fsync, fd);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FSYNC;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FSYNC);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setpriority(int which, int who, int prio)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setpriority, which, who, prio);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setpriority, which, who, prio);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETPRIORITY;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETPRIORITY);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_socket(int domain, int type, int protocol)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_socket, domain, type, protocol);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_socket, domain, type, protocol);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SOCKET;
	e->objectId = (uint64_t) domain;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SOCKET);
	AssertObject(e, (uint64_t) domain);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_connect, s, name, namelen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_connect, s, name, namelen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CONNECT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CONNECT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getpriority(int which, int who)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getpriority, which, who);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getpriority, which, who);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETPRIORITY;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETPRIORITY);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_bind(int s, const struct sockaddr *name, socklen_t namelen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_bind, s, name, namelen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_bind, s, name, namelen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_BIND;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_BIND);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setsockopt(int s, int level, int name, const void *val, socklen_t valsize)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setsockopt, s, level, name, val, valsize);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setsockopt, s, level, name, val, valsize);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETSOCKOPT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETSOCKOPT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_listen(int s, int backlog)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_listen, s, backlog);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_listen, s, backlog);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LISTEN;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LISTEN);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getrusage(int who, struct rusage *rusage)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getrusage, who, rusage);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getrusage, who, rusage);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETRUSAGE;
	e->objectId = (uint64_t) who;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) rusage, (unsigned long)sizeof(struct rusage));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETRUSAGE);
	AssertObject(e, (uint64_t) who);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) rusage, (unsigned long)sizeof(struct rusage));
	}
	break;
    }
    return result;
}

int
__rr_getsockopt(int s, int level, int name, void *val, socklen_t * avalsize)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getsockopt, s, level, name, val, avalsize);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getsockopt, s, level, name, val, avalsize);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETSOCKOPT;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*avalsize);
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (val != NULL) {
		logData((uint8_t *) val, (unsigned long)*avalsize);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETSOCKOPT);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*avalsize) = (socklen_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (val != NULL) {
		logData((uint8_t *) val, (unsigned long)*avalsize);
	    }
	}
	break;
    }
    return result;
}

int
__rr_settimeofday(const struct timeval *tv, const struct timezone *tzp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_settimeofday, tv, tzp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_settimeofday, tv, tzp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETTIMEOFDAY;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETTIMEOFDAY);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchown(int fd, uid_t uid, gid_t gid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fchown, fd, uid, gid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fchown, fd, uid, gid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FCHOWN;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FCHOWN);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchmod(int fd, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fchmod, fd, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fchmod, fd, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FCHMOD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FCHMOD);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setreuid(uid_t ruid, uid_t euid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setreuid, ruid, euid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setreuid, ruid, euid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETREUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETREUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setregid(gid_t rgid, gid_t egid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setregid, rgid, egid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setregid, rgid, egid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETREGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETREGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_rename(const char *from, const char *to)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rename, from, to);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rename, from, to);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RENAME;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RENAME);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_flock(int fd, int how)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_flock, fd, how);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_flock, fd, how);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FLOCK;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FLOCK);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_mkfifo(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_mkfifo, path, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_mkfifo, path, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_MKFIFO;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_MKFIFO);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_sendto(int s, const void *buf, size_t len, int flags, const struct sockaddr *to, socklen_t tolen){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_sendto, s, buf, len, flags, to, tolen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_sendto, s, buf, len, flags, to, tolen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SENDTO;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SENDTO);
	AssertObject(e, (uint64_t) s);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_shutdown(int s, int how)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_shutdown, s, how);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_shutdown, s, how);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SHUTDOWN;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SHUTDOWN);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_mkdir(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_mkdir, path, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_mkdir, path, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_MKDIR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_MKDIR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_rmdir(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rmdir, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rmdir, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RMDIR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RMDIR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_utimes(const char *path, const struct timeval *tptr)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_utimes, path, tptr);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_utimes, path, tptr);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UTIMES;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UTIMES);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_adjtime(const struct timeval *delta, struct timeval *olddelta)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_adjtime, delta, olddelta);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_adjtime, delta, olddelta);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_ADJTIME;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (olddelta != NULL) {
		logData((uint8_t *) olddelta, (unsigned long)sizeof(struct timeval));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_ADJTIME);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (olddelta != NULL) {
		logData((uint8_t *) olddelta, (unsigned long)sizeof(struct timeval));
	    }
	}
	break;
    }
    return result;
}

int
__rr_quotactl(const char *path, int cmd, int uid, void *arg)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_quotactl, path, cmd, uid, arg);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_quotactl, path, cmd, uid, arg);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_QUOTACTL;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_QUOTACTL);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_lgetfh(const char *fname, fhandle_t * fhp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lgetfh, fname, fhp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lgetfh, fname, fhp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LGETFH;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) fhp, (unsigned long)sizeof(fhandle_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LGETFH);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) fhp, (unsigned long)sizeof(fhandle_t));
	}
	break;
    }
    return result;
}

int
__rr_getfh(const char *fname, fhandle_t * fhp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getfh, fname, fhp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getfh, fname, fhp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETFH;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) fhp, (unsigned long)sizeof(fhandle_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETFH);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) fhp, (unsigned long)sizeof(fhandle_t));
	}
	break;
    }
    return result;
}

int
__rr_setfib(int fibnum)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setfib, fibnum);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setfib, fibnum);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETFIB;
	e->objectId = (uint64_t) fibnum;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETFIB);
	AssertObject(e, (uint64_t) fibnum);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_ntp_adjtime(struct timex *tp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_ntp_adjtime, tp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_ntp_adjtime, tp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_NTP_ADJTIME;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) tp, (unsigned long)sizeof(struct timex));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_NTP_ADJTIME);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) tp, (unsigned long)sizeof(struct timex));
	}
	break;
    }
    return result;
}

int
__rr_setgid(gid_t gid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setgid, gid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setgid, gid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setegid(gid_t egid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setegid, egid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setegid, egid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETEGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETEGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_seteuid(uid_t euid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_seteuid, euid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_seteuid, euid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETEUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETEUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

long
__rr_pathconf(const char *path, int name)
{
    long	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_pathconf, path, name);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_pathconf, path, name);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_PATHCONF;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_PATHCONF);
	result = (long)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

long
__rr_fpathconf(int fd, int name)
{
    long	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fpathconf, fd, name);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fpathconf, fd, name);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FPATHCONF;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FPATHCONF);
	AssertObject(e, (uint64_t) fd);
	result = (long)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getrlimit(int which, struct rlimit *rlp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getrlimit, which, rlp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getrlimit, which, rlp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETRLIMIT;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) rlp, (unsigned long)sizeof(struct rlimit));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETRLIMIT);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) rlp, (unsigned long)sizeof(struct rlimit));
	}
	break;
    }
    return result;
}

int
__rr_setrlimit(int which, const struct rlimit *rlp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setrlimit, which, rlp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setrlimit, which, rlp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETRLIMIT;
	e->objectId = (uint64_t) which;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETRLIMIT);
	AssertObject(e, (uint64_t) which);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_undelete(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_undelete, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_undelete, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UNDELETE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UNDELETE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_futimes(int fd, const struct timeval *tptr)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_futimes, fd, tptr);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_futimes, fd, tptr);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FUTIMES;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FUTIMES);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_poll(struct pollfd *fds, nfds_t nfds, int timeout)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_poll, fds, nfds, timeout);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_poll, fds, nfds, timeout);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_POLL;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) fds, (unsigned long)nfds * sizeof(struct pollfd));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_POLL);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) fds, (unsigned long)nfds * sizeof(struct pollfd));
	}
	break;
    }
    return result;
}

int
__rr_clock_settime(clockid_t clock_id, const struct timespec *tp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_clock_settime, clock_id, tp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_clock_settime, clock_id, tp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CLOCK_SETTIME;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CLOCK_SETTIME);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_clock_getres(clockid_t clock_id, struct timespec *tp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_clock_getres, clock_id, tp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_clock_getres, clock_id, tp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CLOCK_GETRES;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) tp, (unsigned long)sizeof(struct timespec));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CLOCK_GETRES);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) tp, (unsigned long)sizeof(struct timespec));
	}
	break;
    }
    return result;
}

int
__rr_ffclock_getcounter(ffcounter * ffcount)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_ffclock_getcounter, ffcount);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_ffclock_getcounter, ffcount);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FFCLOCK_GETCOUNTER;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*ffcount);
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FFCLOCK_GETCOUNTER);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*ffcount) = (ffcounter) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_ffclock_setestimate(struct ffclock_estimate *cest)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_ffclock_setestimate, cest);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_ffclock_setestimate, cest);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FFCLOCK_SETESTIMATE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FFCLOCK_SETESTIMATE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_ffclock_getestimate(struct ffclock_estimate *cest)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_ffclock_getestimate, cest);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_ffclock_getestimate, cest);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FFCLOCK_GETESTIMATE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) cest, (unsigned long)sizeof(struct ffclock_estimate));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FFCLOCK_GETESTIMATE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) cest, (unsigned long)sizeof(struct ffclock_estimate));
	}
	break;
    }
    return result;
}

int
__rr_ntp_gettime(struct ntptimeval *ntvp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_ntp_gettime, ntvp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_ntp_gettime, ntvp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_NTP_GETTIME;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) ntvp, (unsigned long)sizeof(struct ntptimeval));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_NTP_GETTIME);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) ntvp, (unsigned long)sizeof(struct ntptimeval));
	}
	break;
    }
    return result;
}

int
__rr_issetugid()
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_issetugid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_issetugid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_ISSETUGID;
	e->value[0] = (uint64_t) result;
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_ISSETUGID);
	result = (int)e->value[0];
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_lchown(const char *path, uid_t uid, gid_t gid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lchown, path, uid, gid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lchown, path, uid, gid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LCHOWN;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LCHOWN);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_lchmod(const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lchmod, path, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lchmod, path, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LCHMOD;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LCHMOD);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_lutimes(const char *path, const struct timeval *tptr)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lutimes, path, tptr);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lutimes, path, tptr);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LUTIMES;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LUTIMES);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fhopen(const struct fhandle *u_fhp, int flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fhopen, u_fhp, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fhopen, u_fhp, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FHOPEN;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FHOPEN);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setresuid(uid_t ruid, uid_t euid, uid_t suid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setresuid, ruid, euid, suid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setresuid, ruid, euid, suid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETRESUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETRESUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setresgid(gid_t rgid, gid_t egid, gid_t sgid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setresgid, rgid, egid, sgid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setresgid, rgid, egid, sgid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETRESGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETRESGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_extattrctl(const char *path, int cmd, const char *filename, int attrnamespace, const char *attrname)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattrctl, path, cmd, filename, attrnamespace, attrname);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattrctl, path, cmd, filename, attrnamespace, attrname);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTRCTL;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTRCTL);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_set_file(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_set_file, path, attrnamespace, attrname, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_set_file, path, attrnamespace, attrname, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_SET_FILE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_SET_FILE);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_get_file(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_get_file, path, attrnamespace, attrname, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_get_file, path, attrnamespace, attrname, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_GET_FILE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) data, (unsigned long)nbytes);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_GET_FILE);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) data, (unsigned long)nbytes);
	}
	break;
    }
    return result;
}

int
__rr_extattr_delete_file(const char *path, int attrnamespace, const char *attrname)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_delete_file, path, attrnamespace, attrname);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_delete_file, path, attrnamespace, attrname);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_DELETE_FILE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_DELETE_FILE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getresuid(uid_t * ruid, uid_t * euid, uid_t * suid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getresuid, ruid, euid, suid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getresuid, ruid, euid, suid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETRESUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    if (ruid != NULL) {
		e->value[2] = (uint64_t) (*ruid);
	    }
	    if (euid != NULL) {
		e->value[3] = (uint64_t) (*euid);
	    }
	    if (suid != NULL) {
		e->value[4] = (uint64_t) (*suid);
	    }
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETRESUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    if (ruid != NULL) {
		(*ruid) = (uid_t) e->value[2];
	    }
	    if (euid != NULL) {
		(*euid) = (uid_t) e->value[3];
	    }
	    if (suid != NULL) {
		(*suid) = (uid_t) e->value[4];
	    }
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getresgid(gid_t * rgid, gid_t * egid, gid_t * sgid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getresgid, rgid, egid, sgid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getresgid, rgid, egid, sgid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETRESGID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    if (rgid != NULL) {
		e->value[2] = (uint64_t) (*rgid);
	    }
	    if (egid != NULL) {
		e->value[3] = (uint64_t) (*egid);
	    }
	    if (sgid != NULL) {
		e->value[4] = (uint64_t) (*sgid);
	    }
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETRESGID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    if (rgid != NULL) {
		(*rgid) = (gid_t) e->value[2];
	    }
	    if (egid != NULL) {
		(*egid) = (gid_t) e->value[3];
	    }
	    if (sgid != NULL) {
		(*sgid) = (gid_t) e->value[4];
	    }
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_kqueue()
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_kqueue);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_kqueue);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_KQUEUE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_KQUEUE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_set_fd(int fd, int attrnamespace, const char *attrname, const void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_set_fd, fd, attrnamespace, attrname, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_set_fd, fd, attrnamespace, attrname, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_SET_FD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_SET_FD);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_get_fd(int fd, int attrnamespace, const char *attrname, void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_get_fd, fd, attrnamespace, attrname, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_get_fd, fd, attrnamespace, attrname, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_GET_FD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) data, (unsigned long)nbytes);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_GET_FD);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) data, (unsigned long)nbytes);
	}
	break;
    }
    return result;
}

int
__rr_extattr_delete_fd(int fd, int attrnamespace, const char *attrname)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_delete_fd, fd, attrnamespace, attrname);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_delete_fd, fd, attrnamespace, attrname);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_DELETE_FD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_DELETE_FD);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_eaccess(const char *path, int amode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_eaccess, path, amode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_eaccess, path, amode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EACCESS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EACCESS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_nmount(struct iovec *iovp, unsigned int iovcnt, int flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_nmount, iovp, iovcnt, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_nmount, iovp, iovcnt, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_NMOUNT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_NMOUNT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_kenv(int what, const char *name, char *value, int len)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_kenv, what, name, value, len);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_kenv, what, name, value, len);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_KENV;
	e->objectId = (uint64_t) what;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (value != NULL) {
		logData((uint8_t *) value, (unsigned long)len * sizeof(char));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_KENV);
	AssertObject(e, (uint64_t) what);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (value != NULL) {
		logData((uint8_t *) value, (unsigned long)len * sizeof(char));
	    }
	}
	break;
    }
    return result;
}

int
__rr_lchflags(const char *path, unsigned long flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lchflags, path, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lchflags, path, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LCHFLAGS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LCHFLAGS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_uuidgen(struct uuid *store, int count)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_uuidgen, store, count);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_uuidgen, store, count);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UUIDGEN;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) store, (unsigned long)count * sizeof(struct uuid));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UUIDGEN);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) store, (unsigned long)count * sizeof(struct uuid));
	}
	break;
    }
    return result;
}

int
__rr_sendfile(int fd, int s, off_t offset, size_t nbytes, struct sf_hdtr *hdtr, off_t * sbytes, int flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_sendfile, fd, s, offset, nbytes, hdtr, sbytes, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_sendfile, fd, s, offset, nbytes, hdtr, sbytes, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SENDFILE;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    if (sbytes != NULL) {
		e->value[2] = (uint64_t) (*sbytes);
	    }
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SENDFILE);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    if (sbytes != NULL) {
		(*sbytes) = (off_t) e->value[2];
	    }
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_set_link(const char *path, int attrnamespace, const char *attrname, const void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_set_link, path, attrnamespace, attrname, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_set_link, path, attrnamespace, attrname, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_SET_LINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_SET_LINK);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_get_link(const char *path, int attrnamespace, const char *attrname, void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_get_link, path, attrnamespace, attrname, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_get_link, path, attrnamespace, attrname, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_GET_LINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) data, (unsigned long)nbytes);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_GET_LINK);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) data, (unsigned long)nbytes);
	}
	break;
    }
    return result;
}

int
__rr_extattr_delete_link(const char *path, int attrnamespace, const char *attrname)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_delete_link, path, attrnamespace, attrname);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_delete_link, path, attrnamespace, attrname);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_DELETE_LINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_DELETE_LINK);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_extattr_list_fd(int fd, int attrnamespace, void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_list_fd, fd, attrnamespace, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_list_fd, fd, attrnamespace, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_LIST_FD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (data != NULL) {
		logData((uint8_t *) data, (unsigned long)nbytes);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_LIST_FD);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (data != NULL) {
		logData((uint8_t *) data, (unsigned long)nbytes);
	    }
	}
	break;
    }
    return result;
}

ssize_t
__rr_extattr_list_file(const char *path, int attrnamespace, void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_list_file, path, attrnamespace, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_list_file, path, attrnamespace, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_LIST_FILE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (data != NULL) {
		logData((uint8_t *) data, (unsigned long)nbytes);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_LIST_FILE);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (data != NULL) {
		logData((uint8_t *) data, (unsigned long)nbytes);
	    }
	}
	break;
    }
    return result;
}

ssize_t
__rr_extattr_list_link(const char *path, int attrnamespace, void *data, size_t nbytes){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_extattr_list_link, path, attrnamespace, data, nbytes);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_extattr_list_link, path, attrnamespace, data, nbytes);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_EXTATTR_LIST_LINK;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (data != NULL) {
		logData((uint8_t *) data, (unsigned long)nbytes);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_EXTATTR_LIST_LINK);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (data != NULL) {
		logData((uint8_t *) data, (unsigned long)nbytes);
	    }
	}
	break;
    }
    return result;
}

int
__rr_audit(const void *record, int length)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_audit, record, length);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_audit, record, length);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_AUDIT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_AUDIT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_auditon(int cmd, void *data, int length)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_auditon, cmd, data, length);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_auditon, cmd, data, length);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_AUDITON;
	e->objectId = (uint64_t) cmd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_AUDITON);
	AssertObject(e, (uint64_t) cmd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getauid(au_id_t * auid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getauid, auid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getauid, auid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETAUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*auid);
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETAUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*auid) = (au_id_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_setauid(const au_id_t * auid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setauid, auid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setauid, auid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETAUID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETAUID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getaudit(struct auditinfo *auditinfo)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getaudit, auditinfo);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getaudit, auditinfo);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETAUDIT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) auditinfo, (unsigned long)sizeof(struct auditinfo));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETAUDIT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) auditinfo, (unsigned long)sizeof(struct auditinfo));
	}
	break;
    }
    return result;
}

int
__rr_setaudit(const struct auditinfo *auditinfo)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setaudit, auditinfo);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setaudit, auditinfo);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETAUDIT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETAUDIT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getaudit_addr(struct auditinfo_addr *auditinfo_addr, int length)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getaudit_addr, auditinfo_addr, length);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getaudit_addr, auditinfo_addr, length);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETAUDIT_ADDR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) auditinfo_addr, (unsigned long)length);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETAUDIT_ADDR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) auditinfo_addr, (unsigned long)length);
	}
	break;
    }
    return result;
}

int
__rr_setaudit_addr(const struct auditinfo_addr *auditinfo_addr, int length)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setaudit_addr, auditinfo_addr, length);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setaudit_addr, auditinfo_addr, length);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETAUDIT_ADDR;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETAUDIT_ADDR);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_auditctl(const char *path)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_auditctl, path);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_auditctl, path);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_AUDITCTL;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_AUDITCTL);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_pread(int fd, void *buf, size_t nbyte, off_t offset){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_pread, fd, buf, nbyte, offset);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_pread, fd, buf, nbyte, offset);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_PREAD;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)result);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_PREAD);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)result);
	}
	break;
    }
    return result;
}

__off_t
__rr_lseek(int fd, __off_t offset, int whence){
    __off_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lseek, fd, offset, whence);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lseek, fd, offset, whence);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LSEEK;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LSEEK);
	AssertObject(e, (uint64_t) fd);
	result = (__off_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_truncate(const char *path, __off_t length)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_truncate, path, length);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_truncate, path, length);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_TRUNCATE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_TRUNCATE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_ftruncate(int fd, __off_t length)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_ftruncate, fd, length);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_ftruncate, fd, length);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FTRUNCATE;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FTRUNCATE);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cpuset(cpusetid_t * setid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cpuset, setid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cpuset, setid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CPUSET;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*setid);
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CPUSET);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*setid) = (cpusetid_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cpuset_setid(cpuwhich_t which, id_t id, cpusetid_t setid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cpuset_setid, which, id, setid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cpuset_setid, which, id, setid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CPUSET_SETID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CPUSET_SETID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cpuset_getid(cpulevel_t level, cpuwhich_t which, id_t id, cpusetid_t * setid)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cpuset_getid, level, which, id, setid);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cpuset_getid, level, which, id, setid);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CPUSET_GETID;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*setid);
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CPUSET_GETID);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*setid) = (cpusetid_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cpuset_getaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, cpuset_t * mask)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cpuset_getaffinity, level, which, id, cpusetsize, mask);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cpuset_getaffinity, level, which, id, cpusetsize, mask);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CPUSET_GETAFFINITY;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) mask, (unsigned long)sizeof(cpuset_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CPUSET_GETAFFINITY);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) mask, (unsigned long)sizeof(cpuset_t));
	}
	break;
    }
    return result;
}

int
__rr_cpuset_setaffinity(cpulevel_t level, cpuwhich_t which, id_t id, size_t cpusetsize, const cpuset_t * mask)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cpuset_setaffinity, level, which, id, cpusetsize, mask);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cpuset_setaffinity, level, which, id, cpusetsize, mask);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CPUSET_SETAFFINITY;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) mask, (unsigned long)sizeof(const cpuset_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CPUSET_SETAFFINITY);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) mask, (unsigned long)sizeof(const cpuset_t));
	}
	break;
    }
    return result;
}

int
__rr_faccessat(int fd, const char *path, int amode, int flag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_faccessat, fd, path, amode, flag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_faccessat, fd, path, amode, flag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FACCESSAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FACCESSAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchmodat(int fd, const char *path, mode_t mode, int flag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fchmodat, fd, path, mode, flag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fchmodat, fd, path, mode, flag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FCHMODAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FCHMODAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fchownat(int fd, const char *path, uid_t uid, gid_t gid, int flag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fchownat, fd, path, uid, gid, flag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fchownat, fd, path, uid, gid, flag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FCHOWNAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FCHOWNAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_linkat(int fd1, const char *path1, int fd2, const char *path2, int flag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_linkat, fd1, path1, fd2, path2, flag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_linkat, fd1, path1, fd2, path2, flag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LINKAT;
	e->objectId = (uint64_t) fd1;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LINKAT);
	AssertObject(e, (uint64_t) fd1);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_mkdirat(int fd, const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_mkdirat, fd, path, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_mkdirat, fd, path, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_MKDIRAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_MKDIRAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_mkfifoat(int fd, const char *path, mode_t mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_mkfifoat, fd, path, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_mkfifoat, fd, path, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_MKFIFOAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_MKFIFOAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_readlinkat(int fd, const char *path, char *buf, size_t bufsize){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_readlinkat, fd, path, buf, bufsize);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_readlinkat, fd, path, buf, bufsize);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_READLINKAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)bufsize);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_READLINKAT);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)bufsize);
	}
	break;
    }
    return result;
}

int
__rr_renameat(int oldfd, const char *old, int newfd, const char *new)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_renameat, oldfd, old, newfd, new);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_renameat, oldfd, old, newfd, new);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RENAMEAT;
	e->objectId = (uint64_t) oldfd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RENAMEAT);
	AssertObject(e, (uint64_t) oldfd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_symlinkat(const char *path1, int fd, const char *path2)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_symlinkat, path1, fd, path2);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_symlinkat, path1, fd, path2);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SYMLINKAT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SYMLINKAT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_unlinkat(int fd, const char *path, int flag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_unlinkat, fd, path, flag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_unlinkat, fd, path, flag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_UNLINKAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_UNLINKAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

long
__rr_lpathconf(const char *path, int name)
{
    long	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_lpathconf, path, name);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_lpathconf, path, name);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_LPATHCONF;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_LPATHCONF);
	result = (long)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_enter()
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_enter);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_enter);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_ENTER;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_ENTER);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_getmode(u_int * modep)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_getmode, modep);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_getmode, modep);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_GETMODE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*modep);
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_GETMODE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*modep) = (u_int) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_getloginclass(char *namebuf, size_t namelen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getloginclass, namebuf, namelen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getloginclass, namebuf, namelen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETLOGINCLASS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) namebuf, (unsigned long)namelen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETLOGINCLASS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) namebuf, (unsigned long)namelen);
	}
	break;
    }
    return result;
}

int
__rr_setloginclass(const char *namebuf)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_setloginclass, namebuf);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_setloginclass, namebuf);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SETLOGINCLASS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SETLOGINCLASS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_rctl_get_racct(const char *inbufp, size_t inbuflen, char *outbufp, size_t outbuflen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rctl_get_racct, inbufp, inbuflen, outbufp, outbuflen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rctl_get_racct, inbufp, inbuflen, outbufp, outbuflen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RCTL_GET_RACCT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RCTL_GET_RACCT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    }
    return result;
}

int
__rr_rctl_get_rules(const char *inbufp, size_t inbuflen, char *outbufp, size_t outbuflen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rctl_get_rules, inbufp, inbuflen, outbufp, outbuflen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rctl_get_rules, inbufp, inbuflen, outbufp, outbuflen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RCTL_GET_RULES;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RCTL_GET_RULES);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    }
    return result;
}

int
__rr_rctl_get_limits(const char *inbufp, size_t inbuflen, char *outbufp, size_t outbuflen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rctl_get_limits, inbufp, inbuflen, outbufp, outbuflen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rctl_get_limits, inbufp, inbuflen, outbufp, outbuflen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RCTL_GET_LIMITS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RCTL_GET_LIMITS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    }
    return result;
}

int
__rr_rctl_add_rule(const char *inbufp, size_t inbuflen, char *outbufp, size_t outbuflen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rctl_add_rule, inbufp, inbuflen, outbufp, outbuflen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rctl_add_rule, inbufp, inbuflen, outbufp, outbuflen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RCTL_ADD_RULE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RCTL_ADD_RULE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    }
    return result;
}

int
__rr_rctl_remove_rule(const char *inbufp, size_t inbuflen, char *outbufp, size_t outbuflen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_rctl_remove_rule, inbufp, inbuflen, outbufp, outbuflen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_rctl_remove_rule, inbufp, inbuflen, outbufp, outbuflen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_RCTL_REMOVE_RULE;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_RCTL_REMOVE_RULE);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) outbufp, (unsigned long)outbuflen);
	}
	break;
    }
    return result;
}

int
__rr_posix_fallocate(int fd, off_t offset, off_t len)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_posix_fallocate, fd, offset, len);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_posix_fallocate, fd, offset, len);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_POSIX_FALLOCATE;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_POSIX_FALLOCATE);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_posix_fadvise(int fd, off_t offset, off_t len, int advice)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_posix_fadvise, fd, offset, len, advice);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_posix_fadvise, fd, offset, len, advice);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_POSIX_FADVISE;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_POSIX_FADVISE);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_rights_limit(int fd, const cap_rights_t * rightsp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_rights_limit, fd, rightsp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_rights_limit, fd, rightsp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_RIGHTS_LIMIT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_RIGHTS_LIMIT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_ioctls_limit(int fd, const cap_ioctl_t * cmds, size_t ncmds)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_ioctls_limit, fd, cmds, ncmds);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_ioctls_limit, fd, cmds, ncmds);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_IOCTLS_LIMIT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_IOCTLS_LIMIT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

ssize_t
__rr_cap_ioctls_get(int fd, cap_ioctl_t * cmds, size_t maxcmds){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_ioctls_get, fd, cmds, maxcmds);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_ioctls_get, fd, cmds, maxcmds);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_IOCTLS_GET;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) cmds, (unsigned long)maxcmds * sizeof(cap_ioctl_t));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_IOCTLS_GET);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) cmds, (unsigned long)maxcmds * sizeof(cap_ioctl_t));
	}
	break;
    }
    return result;
}

int
__rr_cap_fcntls_limit(int fd, uint32_t fcntlrights)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_fcntls_limit, fd, fcntlrights);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_fcntls_limit, fd, fcntlrights);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_FCNTLS_LIMIT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_FCNTLS_LIMIT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_cap_fcntls_get(int fd, uint32_t * fcntlrightsp)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_cap_fcntls_get, fd, fcntlrightsp);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_cap_fcntls_get, fd, fcntlrightsp);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CAP_FCNTLS_GET;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*fcntlrightsp);
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CAP_FCNTLS_GET);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*fcntlrightsp) = (uint32_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_bindat(int fd, int s, const struct sockaddr *name, socklen_t namelen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_bindat, fd, s, name, namelen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_bindat, fd, s, name, namelen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_BINDAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_BINDAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_connectat(int fd, int s, const struct sockaddr *name, socklen_t namelen)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_connectat, fd, s, name, namelen);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_connectat, fd, s, name, namelen);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CONNECTAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CONNECTAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_chflagsat(int fd, const char *path, unsigned long flags, int atflag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_chflagsat, fd, path, flags, atflag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_chflagsat, fd, path, flags, atflag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_CHFLAGSAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_CHFLAGSAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_accept4(int s, struct sockaddr *name, socklen_t * anamelen, int flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_accept4, s, name, anamelen, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_accept4, s, name, anamelen, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_ACCEPT4;
	e->objectId = (uint64_t) s;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    if (anamelen != NULL) {
		e->value[2] = (uint64_t) (*anamelen);
	    }
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, (unsigned long)*anamelen);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_ACCEPT4);
	AssertObject(e, (uint64_t) s);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    if (anamelen != NULL) {
		(*anamelen) = (socklen_t) e->value[2];
	    }
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (name != NULL) {
		logData((uint8_t *) name, (unsigned long)*anamelen);
	    }
	}
	break;
    }
    return result;
}

int
__rr_fdatasync(int fd)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fdatasync, fd);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fdatasync, fd);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FDATASYNC;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FDATASYNC);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_fstat(int fd, struct stat *sb)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fstat, fd, sb);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fstat, fd, sb);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FSTAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) sb, (unsigned long)sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FSTAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) sb, (unsigned long)sizeof(struct stat));
	}
	break;
    }
    return result;
}

int
__rr_fstatat(int fd, const char *path, struct stat *buf, int flag)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fstatat, fd, path, buf, flag);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fstatat, fd, path, buf, flag);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FSTATAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FSTATAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct stat));
	}
	break;
    }
    return result;
}

int
__rr_fhstat(const struct fhandle *u_fhp, struct stat *sb)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fhstat, u_fhp, sb);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fhstat, u_fhp, sb);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FHSTAT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) sb, (unsigned long)sizeof(struct stat));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FHSTAT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) sb, (unsigned long)sizeof(struct stat));
	}
	break;
    }
    return result;
}

ssize_t
__rr_getdirentries(int fd, char *buf, size_t count, off_t * basep){
    ssize_t	    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getdirentries, fd, buf, count, basep);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getdirentries, fd, buf, count, basep);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETDIRENTRIES;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	} else {
	    e->value[2] = (uint64_t) (*basep);
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)result);
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETDIRENTRIES);
	AssertObject(e, (uint64_t) fd);
	result = (ssize_t) e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	} else {
	    (*basep) = (off_t) e->value[2];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)result);
	}
	break;
    }
    return result;
}

int
__rr_statfs(const char *path, struct statfs *buf)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_statfs, path, buf);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_statfs, path, buf);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_STATFS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct statfs));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_STATFS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct statfs));
	}
	break;
    }
    return result;
}

int
__rr_fstatfs(int fd, struct statfs *buf)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fstatfs, fd, buf);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fstatfs, fd, buf);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FSTATFS;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct statfs));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FSTATFS);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct statfs));
	}
	break;
    }
    return result;
}

int
__rr_getfsstat(struct statfs *buf, long bufsize, int mode)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_getfsstat, buf, bufsize, mode);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_getfsstat, buf, bufsize, mode);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_GETFSSTAT;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (buf != NULL) {
		logData((uint8_t *) buf, (unsigned long)bufsize);
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_GETFSSTAT);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (buf != NULL) {
		logData((uint8_t *) buf, (unsigned long)bufsize);
	    }
	}
	break;
    }
    return result;
}

int
__rr_fhstatfs(const struct fhandle *u_fhp, struct statfs *buf)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_fhstatfs, u_fhp, buf);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_fhstatfs, u_fhp, buf);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_FHSTATFS;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct statfs));
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_FHSTATFS);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    logData((uint8_t *) buf, (unsigned long)sizeof(struct statfs));
	}
	break;
    }
    return result;
}

int
__rr_mknodat(int fd, const char *path, mode_t mode, dev_t dev)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_mknodat, fd, path, mode, dev);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_mknodat, fd, path, mode, dev);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_MKNODAT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_MKNODAT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

int
__rr_kevent(int fd, const struct kevent *changelist, int nchanges, struct kevent *eventlist, int nevents, const struct timespec *timeout)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_kevent, fd, changelist, nchanges, eventlist, nevents, timeout);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_kevent, fd, changelist, nchanges, eventlist, nevents, timeout);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_KEVENT;
	e->objectId = (uint64_t) fd;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	if (result != -1) {
	    if (eventlist != NULL) {
		logData((uint8_t *) eventlist, (unsigned long)result * sizeof(struct kevent));
	    }
	}
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_KEVENT);
	AssertObject(e, (uint64_t) fd);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	if (result != -1) {
	    if (eventlist != NULL) {
		logData((uint8_t *) eventlist, (unsigned long)result * sizeof(struct kevent));
	    }
	}
	break;
    }
    return result;
}

int
__rr_swapoff(const char *name, u_int flags)
{
    int		    result;
    RRLogEntry	   *e;

    switch (rrMode) {
    case RRMODE_NORMAL:
	return __rr_syscall(SYS_swapoff, name, flags);
    case RRMODE_RECORD:
	result = __rr_syscall(SYS_swapoff, name, flags);
	e = RRLog_Alloc(rrlog, getThreadId());
	e->event = RREVENT_SWAPOFF;
	e->value[0] = (uint64_t) result;
	if (result == -1) {
	    e->value[1] = (uint64_t) errno;
	}
	RRLog_Append(rrlog, e);
	break;
    case RRMODE_REPLAY:
	e = RRPlay_Dequeue(rrlog, getThreadId());
	AssertEvent(e, RREVENT_SWAPOFF);
	result = (int)e->value[0];
	if (result == -1) {
	    errno = e->value[1];
	}
	RRPlay_Free(rrlog, e);
	break;
    }
    return result;
}

BIND_REF(read);
BIND_REF(link);
BIND_REF(unlink);
BIND_REF(chdir);
BIND_REF(fchdir);
BIND_REF(chmod);
BIND_REF(chown);
BIND_REF(getpid);
BIND_REF(mount);
BIND_REF(unmount);
BIND_REF(setuid);
BIND_REF(getuid);
BIND_REF(geteuid);
BIND_REF(sendmsg);
BIND_REF(accept);
BIND_REF(getpeername);
BIND_REF(getsockname);
BIND_REF(access);
BIND_REF(chflags);
BIND_REF(fchflags);
BIND_REF(getppid);
BIND_REF(dup);
BIND_REF(getegid);
BIND_REF(getgid);
BIND_REF(acct);
BIND_REF(reboot);
BIND_REF(symlink);
BIND_REF(readlink);
BIND_REF(umask);
BIND_REF(chroot);
BIND_REF(getgroups);
BIND_REF(setgroups);
BIND_REF(setitimer);
BIND_REF(swapon);
BIND_REF(getitimer);
BIND_REF(getdtablesize);
BIND_REF(dup2);
BIND_REF(select);
BIND_REF(fsync);
BIND_REF(setpriority);
BIND_REF(socket);
BIND_REF(connect);
BIND_REF(getpriority);
BIND_REF(bind);
BIND_REF(setsockopt);
BIND_REF(listen);
BIND_REF(getrusage);
BIND_REF(getsockopt);
BIND_REF(settimeofday);
BIND_REF(fchown);
BIND_REF(fchmod);
BIND_REF(setreuid);
BIND_REF(setregid);
BIND_REF(rename);
BIND_REF(flock);
BIND_REF(mkfifo);
BIND_REF(sendto);
BIND_REF(shutdown);
BIND_REF(mkdir);
BIND_REF(rmdir);
BIND_REF(utimes);
BIND_REF(adjtime);
BIND_REF(quotactl);
BIND_REF(lgetfh);
BIND_REF(getfh);
BIND_REF(setfib);
BIND_REF(ntp_adjtime);
BIND_REF(setgid);
BIND_REF(setegid);
BIND_REF(seteuid);
BIND_REF(pathconf);
BIND_REF(fpathconf);
BIND_REF(getrlimit);
BIND_REF(setrlimit);
BIND_REF(undelete);
BIND_REF(futimes);
BIND_REF(poll);
BIND_REF(clock_settime);
BIND_REF(clock_getres);
BIND_REF(ffclock_getcounter);
BIND_REF(ffclock_setestimate);
BIND_REF(ffclock_getestimate);
BIND_REF(ntp_gettime);
BIND_REF(issetugid);
BIND_REF(lchown);
BIND_REF(lchmod);
BIND_REF(lutimes);
BIND_REF(fhopen);
BIND_REF(setresuid);
BIND_REF(setresgid);
BIND_REF(extattrctl);
BIND_REF(extattr_set_file);
BIND_REF(extattr_get_file);
BIND_REF(extattr_delete_file);
BIND_REF(getresuid);
BIND_REF(getresgid);
BIND_REF(kqueue);
BIND_REF(extattr_set_fd);
BIND_REF(extattr_get_fd);
BIND_REF(extattr_delete_fd);
BIND_REF(eaccess);
BIND_REF(nmount);
BIND_REF(kenv);
BIND_REF(lchflags);
BIND_REF(uuidgen);
BIND_REF(sendfile);
BIND_REF(extattr_set_link);
BIND_REF(extattr_get_link);
BIND_REF(extattr_delete_link);
BIND_REF(extattr_list_fd);
BIND_REF(extattr_list_file);
BIND_REF(extattr_list_link);
BIND_REF(audit);
BIND_REF(auditon);
BIND_REF(getauid);
BIND_REF(setauid);
BIND_REF(getaudit);
BIND_REF(setaudit);
BIND_REF(getaudit_addr);
BIND_REF(setaudit_addr);
BIND_REF(auditctl);
BIND_REF(pread);
BIND_REF(lseek);
BIND_REF(truncate);
BIND_REF(ftruncate);
BIND_REF(cpuset);
BIND_REF(cpuset_setid);
BIND_REF(cpuset_getid);
BIND_REF(cpuset_getaffinity);
BIND_REF(cpuset_setaffinity);
BIND_REF(faccessat);
BIND_REF(fchmodat);
BIND_REF(fchownat);
BIND_REF(linkat);
BIND_REF(mkdirat);
BIND_REF(mkfifoat);
BIND_REF(readlinkat);
BIND_REF(renameat);
BIND_REF(symlinkat);
BIND_REF(unlinkat);
BIND_REF(lpathconf);
BIND_REF(cap_enter);
BIND_REF(cap_getmode);
BIND_REF(getloginclass);
BIND_REF(setloginclass);
BIND_REF(rctl_get_racct);
BIND_REF(rctl_get_rules);
BIND_REF(rctl_get_limits);
BIND_REF(rctl_add_rule);
BIND_REF(rctl_remove_rule);
BIND_REF(posix_fallocate);
BIND_REF(posix_fadvise);
BIND_REF(cap_rights_limit);
BIND_REF(cap_ioctls_limit);
BIND_REF(cap_ioctls_get);
BIND_REF(cap_fcntls_limit);
BIND_REF(cap_fcntls_get);
BIND_REF(bindat);
BIND_REF(connectat);
BIND_REF(chflagsat);
BIND_REF(accept4);
BIND_REF(fdatasync);
BIND_REF(fstat);
BIND_REF(fstatat);
BIND_REF(fhstat);
BIND_REF(getdirentries);
BIND_REF(statfs);
BIND_REF(fstatfs);
BIND_REF(getfsstat);
BIND_REF(fhstatfs);
BIND_REF(mknodat);
BIND_REF(kevent);
BIND_REF(swapoff);
