 $FreeBSD$
;	from: @(#)syscalls.master	8.2 (Berkeley) 1/13/94
;	from: src/sys/kern/syscalls.master 1.107
;
; System call name/number master file.
; Processed to created init_sysent.c, syscalls.c and syscall.h.

; Columns: number audit type name alt{name,tag,rtyp}/comments
;	number	system call number, must be in order
;	audit	the audit event associated with the system call
;		A value of AUE_NULL means no auditing, but it also means that
;		there is no audit event for the call at this time. For the
;		case where the event exists, but we don't want auditing, the
;		event should be #defined to AUE_NULL in audit_kevents.h.
;	type	one of STD, OBSOL, UNIMPL, COMPAT, COMPAT4, COMPAT6,
;		COMPAT7, NODEF, NOARGS, NOPROTO, NOSTD
;		The COMPAT* options may be combined with one or more NO*
;		options separated by '|' with no spaces (e.g. COMPAT|NOARGS)
;	name	psuedo-prototype of syscall routine
;		If one of the following alts is different, then all appear:
;	altname	name of system call if different
;	alttag	name of args struct tag if different from [o]`name'"_args"
;	altrtyp	return type if not int (bogus - syscalls always return int)
;		for UNIMPL/OBSOL, name continues with comments

; types:
;	STD	always included
;	COMPAT	included on COMPAT #ifdef
;	COMPAT4	included on COMPAT4 #ifdef (FreeBSD 4 compat)
;	COMPAT6	included on COMPAT6 #ifdef (FreeBSD 6 compat)
;	COMPAT7	included on COMPAT7 #ifdef (FreeBSD 7 compat)
;	OBSOL	obsolete, not included in system, only specifies name
;	UNIMPL	not implemented, placeholder only
;	NOSTD	implemented but as a lkm that can be statically
;		compiled in; sysent entry will be filled with lkmressys
;		so the SYSCALL_MODULE macro works
;	NOARGS	same as STD except do not create structure in sys/sysproto.h
;	NODEF	same as STD except only have the entry in the syscall table
;		added.  Meaning - do not create structure or function
;		prototype in sys/sysproto.h
;	NOPARSE	don't attempt to generate an argument parse.  Intended
;		for use in cases where annotation is insufficient to
;		accurately check arguments.
;	NOPROTO	same as STD except do not create structure or
;		function prototype in sys/sysproto.h.  Does add a
;		definition to syscall.h besides adding a sysent.

; #ifdef's, etc. may be included, and are copied to the output files.

#include <sys/param.h>
#include <sys/sysent.h>
#include <sys/sysproto.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/user.h>
#include <compat/cheriabi/cheriabi.h>
#include <compat/cheriabi/cheriabi_proto.h>

#if !defined(PAD64_REQUIRED) && (defined(__powerpc__) || defined(__mips__))
#define PAD64_REQUIRED
#endif

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

0	AUE_NULL	STD	{ int cheriabi_syscall(int number); }
1	AUE_EXIT	NOPROTO|NOSTUB	{ void sys_exit(int rval); } exit \
				    sys_exit_args void
2	AUE_FORK	NOPROTO	{ int fork(void); }
3	AUE_READ	NOPROTO	{ ssize_t read(int fd, \
				    _Out_writes_bytes_(nbyte) void *buf, \
				    size_t nbyte); }
4	AUE_WRITE	NOPROTO	{ ssize_t write(int fd, \
				    _In_reads_bytes_(nbyte) const void *buf, \
				    size_t nbyte); }
5	AUE_OPEN_RWTC	STD|VARARG	{ int cheriabi_open( \
				    _In_z_ const char * __capability path, \
				    int flags, \
				    mode_t mode); }
6	AUE_CLOSE	NOPROTO	{ int close(int fd); }
7	AUE_WAIT4	NOPROTO	{ int wait4(int pid, _Out_opt_ int *status, \
				    int options, \
				    _Out_opt_ struct rusage *rusage); }
8	AUE_CREAT	OBSOL	old creat
9	AUE_LINK	STD	{ int cheriabi_link( \
				    _In_z_ const char * __capability path, \
				    _In_z_ const char * __capability to); }
10	AUE_UNLINK	STD	{ int cheriabi_unlink( \
				    _In_z_ const char * __capability path); }
11	AUE_NULL	OBSOL	execv
12	AUE_CHDIR	STD	{ int cheriabi_chdir( \
				    _In_z_ const char * __capability path); }
13	AUE_FCHDIR	NOPROTO	{ int fchdir(int fd); }
14	AUE_MKNOD	OBSOL	fbsd11_mknod
15	AUE_CHMOD	NOPROTO	{ int chmod(_In_z_ const char *path, \
				    mode_t mode); }
16	AUE_CHOWN	NOPROTO	{ int chown(_In_z_ const char *path, int uid, \
				    int gid); }
17	AUE_NULL	OBSOL	obreak
18	AUE_GETFSSTAT	OBSOL	getstatfs
19	AUE_LSEEK	OBSOL	lseek
20	AUE_GETPID	NOPROTO	{ pid_t getpid(void); }
; XXX-BD: should be OBSOL, but need to fix amd
21	AUE_MOUNT	STD	{ int cheriabi_mount( \
				    _In_z_ const char * __capability type, \
				    _In_z_ const char * __capability path, \
				    int flags, \
				    _In_opt_ void * __capability data); }
22	AUE_UMOUNT	NOPROTO	{ int unmount(_In_z_ const char *path, \
				    int flags); }
23	AUE_SETUID	NOPROTO	{ int setuid(uid_t uid); }
24	AUE_GETUID	NOPROTO	{ uid_t getuid(void); }
25	AUE_GETEUID	NOPROTO	{ uid_t geteuid(void); }
26	AUE_PTRACE	NOPROTO	{ int ptrace(int req, pid_t pid, \
				    _Inout_opt_ caddr_t addr, int data); }
27	AUE_RECVMSG	STD	{ ssize_t cheriabi_recvmsg(int s, \
				    _In_ struct msghdr_c *msg, \
				    int flags); }
28	AUE_SENDMSG	STD	{ ssize_t cheriabi_sendmsg(int s, \
				    _In_ const struct msghdr_c *msg, \
				    int flags); }
29	AUE_RECVFROM	NOPROTO	{ ssize_t recvfrom(int s, \
				    _Out_writes_bytes_(len) void *buf, \
				    size_t len, int flags, \
				    _Out_writes_bytes_opt_(*fromlenaddr) \
				    struct sockaddr * __restrict from, \
				    _Inout_opt_ \
				    __socklen_t * __restrict fromlenaddr); }
30	AUE_ACCEPT	NOPROTO	{ int accept(int s, \
				    _Out_writes_bytes_opt_(*anamelen) \
				    struct sockaddr * __restrict name, \
				    _Inout_opt_ __socklen_t *anamelen); }
31	AUE_GETPEERNAME	NOPROTO	{ int getpeername(int fdes, \
				    _Out_writes_bytes_(*alen) \
				    struct sockaddr * __restrict asa, \
				    _Inout_opt_ __socklen_t *alen); }
32	AUE_GETSOCKNAME	NOPROTO	{ int getsockname(int fdes, \
				    _Out_writes_bytes_(*alen) \
				    struct sockaddr * __restrict asa, \
				    _Inout_ __socklen_t *alen); }
33	AUE_ACCESS	NOPROTO	{ int access(_In_z_ const char *path, \
				    int amode); }
34	AUE_CHFLAGS	NOPROTO	{ int chflags(_In_z_ const char *path, \
				    u_long flags); }
35	AUE_FCHFLAGS	NOPROTO	{ int fchflags(int fd, u_long flags); }
36	AUE_SYNC	NOPROTO	{ int sync(void); }
37	AUE_KILL	NOPROTO	{ int kill(int pid, int signum); }
